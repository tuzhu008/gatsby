{"version":3,"sources":["webpack:///component---src-pages-docs-node-apis-js-26a5f0a59f6a9da2f691.js","webpack:///./src/pages/docs/node-apis.js"],"names":["webpackJsonp","254","module","exports","__webpack_require__","Glamor","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","pageQuery","undefined","_extends","assign","target","i","arguments","length","source","key","hasOwnProperty","_react","_react2","_functionList","_functionList2","_typography","_container","_container2","NodeAPIDocs","_React$Component","this","apply","render","createElement","css","marginTop","className","dangerouslySetInnerHTML","__html","marginBottom","rhythm","scale","props","data","allDocumentationJs","edges","map","_ref","node","name","href","functions","Component"],"mappings":"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","file":"component---src-pages-docs-node-apis-js-26a5f0a59f6a9da2f691.js","sourcesContent":["webpackJsonp([120390780987034],{\n\n/***/ 254:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Glamor) {\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.pageQuery = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _react = __webpack_require__(3);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _functionList = __webpack_require__(72);\n\t\n\tvar _functionList2 = _interopRequireDefault(_functionList);\n\t\n\tvar _typography = __webpack_require__(5);\n\t\n\tvar _container = __webpack_require__(8);\n\t\n\tvar _container2 = _interopRequireDefault(_container);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar NodeAPIDocs = function (_React$Component) {\n\t  _inherits(NodeAPIDocs, _React$Component);\n\t\n\t  function NodeAPIDocs() {\n\t    _classCallCheck(this, NodeAPIDocs);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n\t  }\n\t\n\t  NodeAPIDocs.prototype.render = function render() {\n\t    return Glamor.createElement(\n\t      _container2.default,\n\t      null,\n\t      Glamor.createElement(\n\t        \"h1\",\n\t        { css: { marginTop: 0 } },\n\t        \"Gatsby Node APIs\"\n\t      ),\n\t      Glamor.createElement(\n\t        \"p\",\n\t        null,\n\t        \"Gatsby gives plugins and site builders many APIs for controlling your site.\"\n\t      ),\n\t      Glamor.createElement(\n\t        \"h3\",\n\t        null,\n\t        \"Async plugins\"\n\t      ),\n\t      Glamor.createElement(\n\t        \"p\",\n\t        null,\n\t        \"If your plugin performs async operations (disk I/O, database access, calling remote APIs, etc.) you must either return a promise or use the callback passed to the 3rd argument. Gatsby needs to know when plugins are finished as some APIs, to work correctly, require previous APIs to be complete first.\"\n\t      ),\n\t      Glamor.createElement(\n\t        \"pre\",\n\t        null,\n\t        Glamor.createElement(\"code\", {\n\t          className: \"language-javascript\",\n\t          dangerouslySetInnerHTML: {\n\t            __html: \"// Promise API\\nexports.createPages = () => {\\n  return new Promise((resolve, reject) => {\\n    // do async work\\n  })\\n}\\n\\n// Callback API\\nexports.createPages = (_, pluginOptions, cb) => {\\n  // do Async work\\n  cb()\\n}\"\n\t          }\n\t        })\n\t      ),\n\t      Glamor.createElement(\n\t        \"p\",\n\t        null,\n\t        \"If your plugin doesn't do async work, you can just return directly.\"\n\t      ),\n\t      Glamor.createElement(\"hr\", null),\n\t      Glamor.createElement(\n\t        \"h2\",\n\t        { css: { marginBottom: (0, _typography.rhythm)(1 / 2) } },\n\t        \"Usage\"\n\t      ),\n\t      Glamor.createElement(\n\t        \"p\",\n\t        { css: { marginBottom: (0, _typography.rhythm)(1) } },\n\t        \"Implement any of these APIs by exporting them from a file named\",\n\t        \" \",\n\t        Glamor.createElement(\n\t          \"code\",\n\t          null,\n\t          \"gatsby-node.js\"\n\t        ),\n\t        \" in the root of your project.\"\n\t      ),\n\t      Glamor.createElement(\"hr\", null),\n\t      Glamor.createElement(\n\t        \"h2\",\n\t        { css: { marginBottom: (0, _typography.rhythm)(1 / 2) } },\n\t        \"APIs\"\n\t      ),\n\t      Glamor.createElement(\n\t        \"ul\",\n\t        { css: _extends({}, (0, _typography.scale)(-1 / 5)) },\n\t        this.props.data.allDocumentationJs.edges.map(function (_ref, i) {\n\t          var node = _ref.node;\n\t          return Glamor.createElement(\n\t            \"li\",\n\t            { key: \"function list \" + node.name },\n\t            Glamor.createElement(\n\t              \"a\",\n\t              { href: \"#\" + node.name },\n\t              node.name\n\t            )\n\t          );\n\t        })\n\t      ),\n\t      Glamor.createElement(\"br\", null),\n\t      Glamor.createElement(\"hr\", null),\n\t      Glamor.createElement(\n\t        \"h2\",\n\t        null,\n\t        \"Reference\"\n\t      ),\n\t      Glamor.createElement(_functionList2.default, { functions: this.props.data.allDocumentationJs.edges })\n\t    );\n\t  };\n\t\n\t  return NodeAPIDocs;\n\t}(_react2.default.Component);\n\t\n\texports.default = NodeAPIDocs;\n\tvar pageQuery = exports.pageQuery = \"** extracted graphql fragment **\";\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-docs-node-apis-js-26a5f0a59f6a9da2f691.js","import React from \"react\"\n\nimport Functions from \"../../components/function-list\"\nimport { rhythm, scale } from \"../../utils/typography\"\nimport Container from \"../../components/container\"\n\nclass NodeAPIDocs extends React.Component {\n  render() {\n    return (\n      <Container>\n        <h1 css={{ marginTop: 0 }}>Gatsby Node APIs</h1>\n        <p>\n          Gatsby gives plugins and site builders many APIs for controlling your\n          site.\n        </p>\n        <h3>Async plugins</h3>\n        <p>\n          If your plugin performs async operations (disk I/O, database access,\n          calling remote APIs, etc.) you must either return a promise or use the\n          callback passed to the 3rd argument. Gatsby needs to know when plugins\n          are finished as some APIs, to work correctly, require previous APIs to\n          be complete first.\n        </p>\n        <pre>\n          <code\n            className=\"language-javascript\"\n            dangerouslySetInnerHTML={{\n              __html: `// Promise API\nexports.createPages = () => {\n  return new Promise((resolve, reject) => {\n    // do async work\n  })\n}\n\n// Callback API\nexports.createPages = (_, pluginOptions, cb) => {\n  // do Async work\n  cb()\n}`,\n            }}\n          />\n        </pre>\n        <p>\n          If your plugin doesn't do async work, you can just return directly.\n        </p>\n        <hr />\n        <h2 css={{ marginBottom: rhythm(1 / 2) }}>Usage</h2>\n        <p css={{ marginBottom: rhythm(1) }}>\n          Implement any of these APIs by exporting them from a file named{` `}\n          <code>gatsby-node.js</code> in the root of your project.\n        </p>\n        <hr />\n        <h2 css={{ marginBottom: rhythm(1 / 2) }}>APIs</h2>\n        <ul css={{ ...scale(-1 / 5) }}>\n          {this.props.data.allDocumentationJs.edges.map(({ node }, i) => (\n            <li key={`function list ${node.name}`}>\n              <a href={`#${node.name}`}>{node.name}</a>\n            </li>\n          ))}\n        </ul>\n        <br />\n        <hr />\n        <h2>Reference</h2>\n        <Functions functions={this.props.data.allDocumentationJs.edges} />\n      </Container>\n    )\n  }\n}\n\nexport default NodeAPIDocs\n\nexport const pageQuery = graphql`\n  query APINodeDocsQuery {\n    allDocumentationJs(\n      filter: { id: { regex: \"/src.*api-node-docs.js/\" } }\n      sort: { fields: [name] }\n    ) {\n      edges {\n        node {\n          name\n          ...FunctionList\n        }\n      }\n    }\n  }\n`\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/docs/node-apis.js"],"sourceRoot":""}